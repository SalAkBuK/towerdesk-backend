import {
  CanActivate,
  Controller,
  ExecutionContext,
  Get,
  INestApplication,
  Injectable,
  UseGuards,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Test } from '@nestjs/testing';
import { randomUUID } from 'crypto';
import { createValidationPipe } from '../src/common/pipes/validation.pipe';
import { JwtAuthGuard } from '../src/common/guards/jwt-auth.guard';
import { PlatformAuthGuard } from '../src/common/guards/platform-auth.guard';
import { OrgScopeGuard } from '../src/common/guards/org-scope.guard';
import { AuthController } from '../src/modules/auth/auth.controller';
import { AuthRepo } from '../src/modules/auth/auth.repo';
import { AuthService } from '../src/modules/auth/auth.service';
import { AccessControlService } from '../src/modules/access-control/access-control.service';
import { PlatformOrgsController } from '../src/modules/platform/platform-orgs.controller';
import { PlatformOrgsService } from '../src/modules/platform/platform-orgs.service';
import { PrismaService } from '../src/infra/prisma/prisma.service';

type OrgRecord = {
  id: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
};

type RoleRecord = {
  id: string;
  key: string;
  name: string;
  description?: string | null;
  isSystem: boolean;
  createdAt: Date;
  updatedAt: Date;
};

type UserRecord = {
  id: string;
  email: string;
  passwordHash: string;
  refreshTokenHash?: string | null;
  name?: string | null;
  orgId?: string | null;
  mustChangePassword: boolean;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
};

type UserRoleRecord = {
  userId: string;
  roleId: string;
  createdAt: Date;
};

let prisma: InMemoryPrismaService;

class InMemoryPrismaService {
  private orgs: OrgRecord[] = [];
  private roles: RoleRecord[] = [];
  private users: UserRecord[] = [];
  private userRoles: UserRoleRecord[] = [];

  org = {
    findUnique: async ({ where }: { where: { id: string } }) => {
      return this.orgs.find((org) => org.id === where.id) ?? null;
    },
    create: async ({ data }: { data: { name: string } }) => {
      const now = new Date();
      const org: OrgRecord = {
        id: randomUUID(),
        name: data.name,
        createdAt: now,
        updatedAt: now,
      };
      this.orgs.push(org);
      return org;
    },
  };

  role = {
    findUnique: async ({ where }: { where: { key: string } }) => {
      return this.roles.find((role) => role.key === where.key) ?? null;
    },
  };

  user = {
    findUnique: async ({
      where,
    }: {
      where: { id?: string; email?: string };
    }) => {
      if (where.id) {
        return this.users.find((user) => user.id === where.id) ?? null;
      }
      if (where.email) {
        return this.users.find((user) => user.email === where.email) ?? null;
      }
      return null;
    },
    create: async ({
      data,
    }: {
      data: {
        email: string;
        passwordHash: string;
        name?: string | null;
        orgId?: string | null;
        mustChangePassword?: boolean;
        isActive?: boolean;
      };
    }) => {
      const now = new Date();
      const user: UserRecord = {
        id: randomUUID(),
        email: data.email,
        passwordHash: data.passwordHash,
        name: data.name ?? null,
        orgId: data.orgId ?? null,
        mustChangePassword: data.mustChangePassword ?? false,
        isActive: data.isActive ?? true,
        refreshTokenHash: null,
        createdAt: now,
        updatedAt: now,
      };
      this.users.push(user);
      return user;
    },
    update: async ({
      where,
      data,
    }: {
      where: { id: string };
      data: Partial<UserRecord>;
    }) => {
      const user = this.users.find((record) => record.id === where.id);
      if (!user) {
        throw new Error('User not found');
      }
      if (data.email !== undefined) {
        user.email = data.email;
      }
      if (data.passwordHash !== undefined) {
        user.passwordHash = data.passwordHash;
      }
      if (data.refreshTokenHash !== undefined) {
        user.refreshTokenHash = data.refreshTokenHash;
      }
      if (data.name !== undefined) {
        user.name = data.name;
      }
      if (data.orgId !== undefined) {
        user.orgId = data.orgId;
      }
      if (data.mustChangePassword !== undefined) {
        user.mustChangePassword = data.mustChangePassword;
      }
      if (data.isActive !== undefined) {
        user.isActive = data.isActive;
      }
      user.updatedAt = new Date();
      return user;
    },
  };

  userRole = {
    create: async ({
      data,
    }: {
      data: { userId: string; roleId: string };
    }) => {
      const record: UserRoleRecord = {
        userId: data.userId,
        roleId: data.roleId,
        createdAt: new Date(),
      };
      this.userRoles.push(record);
      return record;
    },
  };

  reset() {
    this.orgs = [];
    this.users = [];
    this.userRoles = [];
    this.roles = [];
  }

  seedOrgAdminRole() {
    const now = new Date();
    this.roles.push({
      id: randomUUID(),
      key: 'org_admin',
      name: 'Org Admin',
      description: 'Org administrator',
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    });
  }
}

@Injectable()
class TestJwtAuthGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const userIdHeader = request.headers['x-user-id'];
    const userId = Array.isArray(userIdHeader) ? userIdHeader[0] : userIdHeader;
    if (!userId) {
      return false;
    }
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user) {
      return false;
    }
    request.user = {
      sub: user.id,
      email: user.email,
      orgId: user.orgId ?? null,
    };
    return true;
  }
}

@Controller('org/test')
@UseGuards(JwtAuthGuard, OrgScopeGuard)
class TestOrgController {
  @Get()
  getStatus() {
    return { ok: true };
  }
}

describe('Platform org admin (e2e)', () => {
  let app: INestApplication;
  let baseUrl: string;
  let jwtService: JwtService;
  let platformUser: UserRecord;

  const platformKey = process.env.PLATFORM_API_KEY ?? 'test-platform-key';
  const permissionsByUser = new Map<string, Set<string>>();

  beforeAll(async () => {
    prisma = new InMemoryPrismaService();

    jwtService = {
      signAsync: jest.fn().mockResolvedValue('token'),
      verifyAsync: jest.fn(),
    } as unknown as JwtService;

    const moduleRef = await Test.createTestingModule({
      controllers: [PlatformOrgsController, AuthController, TestOrgController],
      providers: [
        PlatformOrgsService,
        PlatformAuthGuard,
        AuthService,
        AuthRepo,
        {
          provide: AccessControlService,
          useValue: {
            getUserEffectivePermissions: async (userId: string) =>
              permissionsByUser.get(userId) ?? new Set<string>(),
          },
        },
        { provide: PrismaService, useValue: prisma },
        { provide: JwtService, useValue: jwtService },
      ],
    })
      .overrideGuard(JwtAuthGuard)
      .useClass(TestJwtAuthGuard)
      .compile();

    app = moduleRef.createNestApplication();
    app.useGlobalPipes(createValidationPipe());
    await app.init();
    await app.listen(0);
    baseUrl = await app.getUrl();
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    prisma.reset();
    prisma.seedOrgAdminRole();
    permissionsByUser.clear();

    platformUser = await prisma.user.create({
      data: {
        email: 'platform@towerdesk.local',
        passwordHash: 'hash',
        orgId: null,
        name: 'Platform Admin',
        isActive: true,
      },
    }) as unknown as UserRecord;

    permissionsByUser.set(platformUser.id, new Set([
      'platform.org.create',
      'platform.org.admin.create',
    ]));

    (jwtService.verifyAsync as jest.Mock).mockResolvedValue({
      sub: platformUser.id,
      email: platformUser.email,
      orgId: null,
    });
  });

  it('rejects platform access without the platform key', async () => {
    const response = await fetch(`${baseUrl}/platform/orgs`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'Acme Org' }),
    });

    expect(response.status).toBe(401);
  });

  it('creates an org admin and returns mustChangePassword on login', async () => {
    const orgResponse = await fetch(`${baseUrl}/platform/orgs`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-platform-key': platformKey,
      },
      body: JSON.stringify({ name: 'Acme Org' }),
    });

    expect(orgResponse.status).toBe(201);
    const orgBody = await orgResponse.json();

    const adminResponse = await fetch(
      `${baseUrl}/platform/orgs/${orgBody.id}/admins`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-platform-key': platformKey,
        },
        body: JSON.stringify({
          name: 'Org Admin',
          email: 'admin@acme.com',
        }),
      },
    );

    expect(adminResponse.status).toBe(201);
    const adminBody = await adminResponse.json();
    expect(adminBody.tempPassword).toBeTruthy();
    expect(adminBody.mustChangePassword).toBe(true);

    const loginResponse = await fetch(`${baseUrl}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: adminBody.email,
        password: adminBody.tempPassword,
      }),
    });

    expect(loginResponse.status).toBe(200);
    const loginBody = await loginResponse.json();
    expect(loginBody.user.mustChangePassword).toBe(true);
  });

  it('allows platform access with a platform superadmin JWT', async () => {
    const response = await fetch(`${baseUrl}/platform/orgs`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: 'Bearer platform-token',
      },
      body: JSON.stringify({ name: 'JWT Org' }),
    });

    expect(response.status).toBe(201);
  });

  it('blocks platform users from org-scoped routes', async () => {
    const response = await fetch(`${baseUrl}/org/test`, {
      headers: { 'x-user-id': platformUser.id },
    });

    expect(response.status).toBe(403);
  });

  it('clears mustChangePassword after change-password', async () => {
    const orgResponse = await fetch(`${baseUrl}/platform/orgs`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-platform-key': platformKey,
      },
      body: JSON.stringify({ name: 'Bravo Org' }),
    });

    const orgBody = await orgResponse.json();
    const adminResponse = await fetch(
      `${baseUrl}/platform/orgs/${orgBody.id}/admins`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-platform-key': platformKey,
        },
        body: JSON.stringify({
          name: 'Org Admin',
          email: 'admin@bravo.com',
        }),
      },
    );

    const adminBody = await adminResponse.json();

    const changeResponse = await fetch(`${baseUrl}/auth/change-password`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-user-id': adminBody.userId,
      },
      body: JSON.stringify({
        currentPassword: adminBody.tempPassword,
        newPassword: 'NewPassword123!',
      }),
    });

    expect(changeResponse.status).toBe(200);

    const loginResponse = await fetch(`${baseUrl}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: adminBody.email,
        password: 'NewPassword123!',
      }),
    });

    expect(loginResponse.status).toBe(200);
    const loginBody = await loginResponse.json();
    expect(loginBody.user.mustChangePassword).toBe(false);
  });
});
